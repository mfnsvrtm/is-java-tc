# ---------------------------------------------------------------------------- #
# Задание 1                                                                    #
# Работа с типами данных Date, NULL значениями, трехзначная логика. Возвраще-  #
# ние определенных значений в результатах запроса в зависимости от полученных  #
# первоначальных значений результата запроса. Высветка в результатах запроса   #
# только определенных колонок.                                                 #
# ---------------------------------------------------------------------------- #

# 1.1
# Выбрать в таблице Orders заказы, которые были доставлены после 5 мая 1998 года
# (колонка ShippedDate) включительно и которые доставлены с ShipVia >= 2. Формат
# указания даты должен быть верным при любых региональных настройках. Этот метод
# использовать далее для всех заданий. Запрос должен высвечивать только колонки
# OrderID, ShippedDate и ShipVia. Пояснить почему сюда не попали заказы с
# NULL-ом в колонке ShippedDate.

# 1.2
# Написать запрос, который выводит только недоставленные заказы из таблицы
# Orders. В результатах запроса высвечивать для колонки ShippedDate вместо
# значений NULL строку 'Not Shipped' – необходимо использовать CASЕ выражение.
# Запрос должен высвечивать только колонки OrderID и ShippedDate.

# 1.3
# Выбрать в таблице Orders заказы, которые были доставлены после 5 мая 1998 года
# (ShippedDate) не включая эту дату или которые еще не доставлены. В запросе
# должны высвечиваться только колонки OrderID (переименовать в Order Number) и
# ShippedDate (переименовать в Shipped Date). В результатах запроса высвечивать
# для колонки ShippedDate вместо значений NULL строку 'Not Shipped' - необходимо
# использовать функцию NVL, для остальных значений высвечивать дату в формате
# "ДД.ММ.ГГГГ".

# ---------------------------------------------------------------------------- #
# Задание 2                                                                    #
# Использование операторов IN, DISTINCT, ORDER BY, NOT                         #
# ---------------------------------------------------------------------------- #

# 2.1
# Выбрать из таблицы Customers всех заказчиков, проживающих в USA или Canada.
# Запрос сделать с только помощью оператора IN. Высвечивать колонки с именем
# пользователя и названием страны в результатах запроса. Упорядочить результаты
# запроса по имени заказчиков и по месту проживания.

# 2.2
# Выбрать из таблицы Customers всех заказчиков, не проживающих в USA и Canada.
# Запрос сделать с помощью оператора IN. Высвечивать колонки с именем пользова-
# теля и названием страны в результатах запроса. Упорядочить результаты запроса
# по имени заказчиков.

# 2.3
# Выбрать из таблицы Customers все страны, в которых проживают заказчики. Страна
# должна быть упомянута только один раз и список отсортирован по убыванию. Не
# использовать предложение GROUP BY. Высвечивать только одну колонку в результа-
# тах запроса.

# ---------------------------------------------------------------------------- #
# Задание 3                                                                    #
# Использование оператора BETWEEN, DISTINCT                                    #
# ---------------------------------------------------------------------------- #

# 3.1
# Выбрать все заказы (OrderID) из таблицы Order_Details (заказы не должны повто-
# ряться), где встречаются продукты с количеством от 3 до 10 включительно – это
# колонка Quantity в таблице Order_Details. Использовать оператор BETWEEN.
# Запрос должен высвечивать только колонку OrderID.

# 3.2
# Выбрать всех заказчиков из таблицы Customers, у которых название страны
# начинается на буквы из диапазона B и G. Использовать оператор BETWEEN. Прове-
# рить, что в результаты запроса попадает Germany. Запрос должен высвечивать
# только колонки CustomerID и Country и отсортирован по Country.

# 3.3
# Выбрать всех заказчиков из таблицы Customers, у которых название страны начи-
# нается на буквы из диапазона B и G, не используя оператор BETWEEN. Запрос
# должен высвечивать только колонки CustomerID и Country и отсортирован по
# Country. С помощью опции "Execute Explain Plan" определить какой запрос
# предпочтительнее 3.2 или 3.3, необходимо объяснить почему и написать ответ в
# комментариях к текущему запросу.

# ---------------------------------------------------------------------------- #
# Задание 4                                                                    #
# Использование оператора LIKE                                                 #
# ---------------------------------------------------------------------------- #

# 4.1
# В таблице Products найти все продукты (колонка ProductName), где встречается
# подстрока 'chocolade'. Известно, что в подстроке 'chocolade' может быть
# изменена одна буква 'c' в середине - найти все продукты, которые удовлетворяют
# этому условию. Подсказка: в результате должны быть найдены 2 строки.

# ---------------------------------------------------------------------------- #
# Задание 5                                                                    #
# Использование агрегатных функций (SUM, COUNT)                                #
# ---------------------------------------------------------------------------- #

# 5.1
# Найти общую сумму всех заказов из таблицы Order_Details с учетом количества
# закупленных товаров и скидок по ним. Результат округлить до сотых и отобразить
# в стиле: $X,XXX.XX где "$" - валюта доллары, "," – разделитель групп разрядов,
# "." – разделитель целой и дробной части, при этом дробная часть должна
# содержать цифры до сотых, пример: $1,234.00
# Скидка (колонка Discount) составляет процент из стоимости для данного товара.
# Для определениядействительной цены на проданный продукт надо вычесть скидку из
# указанной в колонке UnitPrice цены. Результатом запроса должна быть одна
# запись с одной колонкой с названием колонки 'Totals'.

# 5.2
# По таблице Orders найти количество заказов, которые еще не были доставлены
# (т.е. в колонке ShippedDate нет значения даты доставки). Использовать при этом
# запросе только оператор COUNT. Не использовать предложения WHERE и GROUP.

# 5.3
# По таблице Orders найти количество различных покупателей (CustomerID),
# сделавших заказы. Использовать функцию COUNT и не использовать предложения
# WHERE и GROUP.

# ---------------------------------------------------------------------------- #
# Задание 6                                                                    #
# Явное соединение таблиц, самосоединения, использование агрегатных функций и  #
# предложений GROUP BY и HAVING                                                #
# ---------------------------------------------------------------------------- #

# 6.1
# По таблице Orders найти количество заказов с группировкой по годам. В резуль-
# татах запроса надо высвечивать две колонки c названиями Year и Total. Написать
# проверочный запрос, который вычисляет количество всех заказов.

# 6.2
# По таблице Orders найти количество заказов, cделанных каждым продавцом. Заказ
# для указанного продавца – это любая запись в таблице Orders, где в колонке
# EmployeeID задано значение для данного продавца. В результатах запроса надо
# высвечивать колонку с именем продавца (Должно высвечиваться имя полученное
# конкатенацией LastName & FirstName. Эта строка LastName & FirstName должна
# быть получена отдельным запросом в колонке основного запроса. Также основной
# запрос должен использовать группировку по EmployeeID.) с названием колонки
# 'Seller' и колонку c количеством заказов высвечивать с названием 'Amount'.
# Результаты запроса должны быть упорядочены по убыванию количества заказов.

# 6.3
# Выбрать 5 стран в которых проживает наибольшее количество заказчиков. Список
# должен быть отсортирован по убыванию популярности. Необходимо выводить два
# столбца - Country и Count (количество заказчиков).

# 6.4
# По таблице Orders найти количество заказов, cделанных каждым продавцом и для
# каждого покупателя. Необходимо определить это только для заказов сделанных в
# 1998 году. В результатах запроса надо высвечивать колонку с именем продавца
# (название колонки 'Seller'), колонку с именем покупателя (название колонки
# 'Customer') и колонку c количеством заказов высвечивать с названием 'Amount'.
# В запросе необходимо использовать специальный оператор языка PL/SQL для работы
# с выражением GROUP (Этот же оператор поможет выводить строку "ALL" в
# результатах запроса). Подсказка: использовать операторы: ROLLUP, CUBE,
# GROUPING. Группировки должны быть сделаны по ID продавца и покупателя.
# Результаты запроса должны быть упорядочены по продавцу, покупателю и по
# убыванию количества продаж. В результатах должна быть сводная информация по
# продажам. Т.е. в резульирующем наборе должны присутствовать дополнительно к
# информации о продажах продавца для каждого покупателя следующие строчки:
# +--------+----------+--------------------------------------------------------+
# | Seller | Customer | Amount                                                 |
# | ALL    | ALL      | <общее число продаж>                                   |
# | <имя>  | ALL      | <число продаж данного продавца>                        |
# | ALL    | <имя>    | <число продаж для данного покупателя>                  |
# | <имя>  | <имя>    | <число продаж данного продавца для данного покупателя> |
# +--------+----------+--------------------------------------------------------+
# * обратите внимание: первой строчкод должна выводиться строка ALL-ALL

# 6.5
# Найти покупателей и продавцов, которые живут в одном городе. Если в городе
# живут только один или несколько продавцов или только один или несколько поку-
# пателей, то информация о таких покупателя и продавцах не должна попадать в
# результирующий набор. Не использовать конструкцию JOIN. В результатах запроса
# необходимо вывести следующие заголовки для результатов запроса: 'Person',
# 'Type' (здесь надо выводить строку 'Customer' или 'Seller' в завимости от типа
# записи), 'City'. Отсортировать результаты запроса по колонке 'City' и по
# 'Person'.

# 6.6
# Найти всех покупателей, которые живут в одном городе. В запросе использовать
# соединение таблицы Customers c собой - самосоединение. Высветить колонки
# CustomerID и City. Запрос не должен высвечивать дублируемые записи. Отсорти-
# ровать результаты запроса по колонке City. Для проверки написать запрос, кото-
# рый высвечивает города, которые встречаются более одного раза в таблице
# Customers. Это позволит проверить правильность запроса.

# 6.7
# По таблице Employees найти для каждого продавца его руководителя, т.е. кому он
# делает репорты. Высветить колонки с именами 'User Name' (LastName) и 'Boss'.
# В колонках должны быть высвечены имена из колонки LastName. Высвечены ли все
# продавцы в этом запросе?

# ---------------------------------------------------------------------------- #
# Задание 7                                                                    #
# Использование Inner JOIN                                                     #
# ---------------------------------------------------------------------------- #

# 7.1
# Определить продавцов, которые обслуживают регион 'Western' (таблица Region).
# Результаты запроса должны высвечивать два поля: 'LastName' продавца и название
# обслуживаемой территории ('TerritoryDescription' из таблицы Territories).
# Запрос должен использовать JOIN в предложении FROM. Для определения связей
# между таблицами Employees и Territories надо использовать графическую схему
# для базы Northwind.

# ---------------------------------------------------------------------------- #
# Задание 8                                                                    #
# Использование Outer JOIN                                                     #
# ---------------------------------------------------------------------------- #

# 8.1
# Высветить в результатах запроса имена всех заказчиков из таблицы Customers и
# суммарное количество их заказов из таблицы Orders. Принять во внимание, что
# у некоторых заказчиков нет заказов, но они также должны быть выведены в
# результатах запроса. Упорядочить результаты запроса по возрастанию количества
# заказов.

# ---------------------------------------------------------------------------- #
# Задание 9                                                                    #
# Использование подзапросов                                                    #
# ---------------------------------------------------------------------------- #

# 9.1
# Высветить всех поставщиков колонка CompanyName в таблице Suppliers, у которых
# нет хотя бы одного продукта на складе (UnitsInStock в таблице Products равно
# 0). Использовать вложенный SELECT для этого запроса с использованием оператора
# IN. Можно ли использовать вместо оператора IN оператор '=' ?

# ---------------------------------------------------------------------------- #
# Задание 10                                                                   #
# Коррелированный запрос                                                       #
# ---------------------------------------------------------------------------- #

# 10.1
# Высветить всех продавцов, которые имеют более 150 заказов. Использовать
# вложенный коррелированный SELECT.

# ---------------------------------------------------------------------------- #
# Задание 11                                                                   #
# Использование EXISTS                                                         #
# ---------------------------------------------------------------------------- #

# 11.1
# Высветить всех заказчиков (таблица Customers), которые не имеют ни одного
# заказа (подзапрос по таблице Orders). Использовать коррелированный SELECT и
# оператор EXISTS.

# ---------------------------------------------------------------------------- #
# Задание 12                                                                   #
# Использование строковых функций                                              #
# ---------------------------------------------------------------------------- #

# 12.1
# Для формирования алфавитного указателя Employees высветить из таблицы
# Employees список только тех букв алфавита, с которых начинаются фамилии
# Employees (колонка LastName ) из этой таблицы. Алфавитный список должен
# быть отсортирован по возрастанию.

